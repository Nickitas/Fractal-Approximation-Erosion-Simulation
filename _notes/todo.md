# FRAES | План разработки

### ✅ 1: Базовое представление береговой линии как прямой линии
**ТЗ:** Создать структуру `Point` с полями X и Y (float64). В main определить две точки (начало и конец упрощенной береговой линии, например, от Одессы до Батуми: Point{0,0} и Point{1000,0}). Вычислить и вывести длину линии (евклидово расстояние).

### ✅ 2: Массив точек для полилинии
**Улучшение:** Добавить слайс точек для представления берега как полилинии (несколько сегментов).  
**ТЗ:** Расширить предыдущую программу: создать слайс []Point с 5-ю фиксированными точками (например, добавьте промежуточные для изгиба). Вычислить общую длину полилинии, суммируя расстояния между соседними точками. Использовать цикл for.

### ✅ 3: Функция для генерации случайных точек
**Улучшение:** Ввести случайность для имитации неровностей берега.  
**ТЗ:** Добавить функцию GenerateRandomPoints(n int) []Point, которая генерирует n случайных точек в заданном диапазоне (используйте math/rand). В main сгенерировать 10 точек, отсортируйте по X и вычислите длину полилинии. Вывести координаты.

### ✅ 4: Импорт реальных данных о Черном море
**Улучшение:** Интегрировать реальные координаты (широта/долгота) для аутентичности.  
**ТЗ:** Добавить функцию LoadCoastlineData() []Point, которая hardcoded массив из 10-15 реальных точек берега Черного моря (например, от Википедии: Одесса {46.48, 30.73}, Севастополь {44.62, 33.53} и т.д. — использовать approx. значения). Заменить случайные точки на эти, вычислить длину в км (уч. масштаб: approx. 1 единица = 1 км).

### ⬜️ 5: Простая фрактальная итерация (Кривая Коха на сегменте)
**Улучшение:** Ввести фрактальную геометрию для создания неровностей.  
**ТЗ:** Создать функцию KochCurve(points []Point, iterations int) []Point, которая для каждого сегмента добавляет треугольник (стандартная итерация Коха). Применить 1 итерацию к полилинии из части 4, вычислить новую длину (она вырастет).

### ⬜️ 6: Множественные итерации фрактала
**Улучшение:** Добавить рекурсию для нескольких итераций.  
**ТЗ:** Улучшить KochCurve для рекурсивного применения (до 3-5 итераций, чтобы избежать переполнения). В main применить к реальным точкам, вывести длину на каждой итерации. Добавить проверку на максимальную глубину.

### ⬜️ 7: Вычисление фрактальной размерности
**Улучшение:** Добавить математический анализ (box-counting метод approx.).  
**ТЗ:** Создать функцию FractalDimension(points []Point) float64, которая approx. вычисляет размерность (логарифм числа коробок / логарифм масштаба). Применить после фрактальной генерации, сравните с теоретическим для Коха (~1.26).

### ⬜️ 8: Чтение данных из JSON-файла
**Улучшение:** Сделать данные динамичными, загрузка из файла.  
**ТЗ:** Создать JSON-файл с массивом точек (реальные координаты Черного моря). Добавить функцию LoadFromJSON(filename string) []Point с использованием encoding/json и os. Заменить hardcoded данные, обработайте ошибки.

### ⬜️ 9: Загрузка реальных данных через HTTP
**Улучшение:** Получить актуальные данные онлайн (например, от API или geojson).  
**ТЗ:** Добавить функцию FetchCoastlineData(url string) []Point, используя net/http для GET-запроса к открытому geojson (например, hypothetical "https://example.com/blacksea.json"). Парсить JSON, извлеките координаты. Обновить загрузку, fallback на локальный файл.

### ⬜️ 10: Базовая визуализация в SVG
**Улучшение:** Добавить вывод графики для визуального представления.  
**ТЗ:** Использовать библиотеку (go get github.com/ajstarks/svgo), создать функцию DrawSVG(points []Point, filename string) для рисования полилинии в SVG-файл. Вызывать после фрактальной генерации.

### ⬜️ 11: Симуляция эрозии (случайное смещение точек)
**Улучшение:** Ввести динамику: модель эрозии как случайные сдвиги.  
**ТЗ:** Добавить функцию Erode(points []Point, strength float64) []Point, которая для каждой точки добавляет случайный вектор (gauss распределение). Применить после фрактала, пересчитайте длину и размерность, сгенерируйте новый SVG.

### ⬜️ 12: Множественные шаги симуляции эрозии
**Улучшение:** Сделать симуляцию временной (несколько шагов).  
**ТЗ:** Создать функцию SimulateErosion(points []Point, steps int, strength float64) [][]Point, возвращающую слайс состояний на каждом шаге. В main выведите метрики для каждого шага, сгенерировать серию SVG-файлов.

### ⬜️ 13: Concurrency для ускорения симуляций
**Улучшение:** Параллелизовать вычисления для больших наборов точек.  
**ТЗ:** Использовать goroutines и sync.WaitGroup в SimulateErosion: разделите точки на chunks, эродируйте параллельно. Добавить mutex для синхронизации. Тестировать на большем наборе (100+ точек).

### ⬜️ 14: Расчет площади прибрежных зон
**Улучшение:** Добавить геометрические вычисления площади (shoelace formula).  
**ТЗ:** Предположить замкнутую область (добавить базовую линию для "залива"). Создать функцию Area(points []Point) float64 с shoelace. Вычислить площадь до/после эрозии, интегрировать в симуляцию.

### ⬜️ 15: Полноценное CLI-приложение с опциями
**Улучшение:** Сделать программу полной: CLI с флагами, логирование, экспорт результатов.  
**ТЗ:** Использовать flag для параметров (iterations, steps, strength, output dir). В main: загрузить данные (HTTP или файл), применить фрактал, симулировать эрозию с concurrency, вычислять метрики (длина, размерность, площадь), сгенерировать SVG для каждого шага, экспортировать JSON с результатами. Добавить обработку ошибок и verbose logging. Это финальная robust реализация.