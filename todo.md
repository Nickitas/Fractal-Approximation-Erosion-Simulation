# FRAES (Fractal Approximation & Erosion Simulation)

### Часть 1: Базовое представление береговой линии как прямой линии
**ТЗ:** Создать структуру `Point` с полями X и Y (float64). В main определить две точки (начало и конец упрощенной береговой линии, например, от Одессы до Батуми: Point{0,0} и Point{1000,0}). Вычислить и вывести длину линии (евклидово расстояние).

### Часть 2: Массив точек для полилинии
**Улучшение:** Добавить слайс точек для представления берега как полилинии (несколько сегментов).  
**ТЗ:** Расширить предыдущую программу: создать слайс []Point с 5-ю фиксированными точками (например, добавьте промежуточные для изгиба). Вычислить общую длину полилинии, суммируя расстояния между соседними точками. Использовать цикл for.

### Часть 3: Функция для генерации случайных точек
**Улучшение:** Ввести случайность для имитации неровностей берега.  
**ТЗ:** Добавить функцию GenerateRandomPoints(n int) []Point, которая генерирует n случайных точек в заданном диапазоне (используйте math/rand). В main сгенерировать 10 точек, отсортируйте по X и вычислите длину полилинии. Вывести координаты.

### Часть 4: Импорт реальных данных о Черном море
**Улучшение:** Интегрируйте реальные координаты (широта/долгота) для аутентичности.  
**ТЗ:** Добавьте функцию LoadCoastlineData() []Point, которая hardcoded массив из 10-15 реальных точек берега Черного моря (например, от Википедии: Одесса {46.48, 30.73}, Севастополь {44.62, 33.53} и т.д. — используйте approx. значения). Замените случайные точки на эти, вычислите длину в км (учтите масштаб: approx. 1 единица = 1 км).

### Часть 5: Простая фрактальная итерация (Кривая Коха на сегменте)
**Улучшение:** Введите фрактальную геометрию для создания неровностей.  
**ТЗ:** Создайте функцию KochCurve(points []Point, iterations int) []Point, которая для каждого сегмента добавляет треугольник (стандартная итерация Коха). Примените 1 итерацию к полилинии из части 4, вычислите новую длину (она вырастет).

### Часть 6: Множественные итерации фрактала
**Улучшение:** Добавьте рекурсию для нескольких итераций.  
**ТЗ:** Улучшите KochCurve для рекурсивного применения (до 3-5 итераций, чтобы избежать переполнения). В main примените к реальным точкам, выведите длину на каждой итерации. Добавьте проверку на максимальную глубину.

### Часть 7: Вычисление фрактальной размерности
**Улучшение:** Добавьте математический анализ (box-counting метод approx.).  
**ТЗ:** Создайте функцию FractalDimension(points []Point) float64, которая approx. вычисляет размерность (логарифм числа коробок / логарифм масштаба). Примените после фрактальной генерации, сравните с теоретическим для Коха (~1.26).

### Часть 8: Чтение данных из JSON-файла
**Улучшение:** Сделайте данные динамичными, загрузка из файла.  
**ТЗ:** Создайте JSON-файл с массивом точек (реальные координаты Черного моря). Добавьте функцию LoadFromJSON(filename string) []Point с использованием encoding/json и os. Замените hardcoded данные, обработайте ошибки.

### Часть 9: Загрузка реальных данных через HTTP
**Улучшение:** Получите актуальные данные онлайн (например, от API или geojson).  
**ТЗ:** Добавьте функцию FetchCoastlineData(url string) []Point, используя net/http для GET-запроса к открытому geojson (например, hypothetical "https://example.com/blacksea.json"). Парсите JSON, извлеките координаты. Обновите загрузку, fallback на локальный файл.

### Часть 10: Базовая визуализация в SVG
**Улучшение:** Добавьте вывод графики для визуального представления.  
**ТЗ:** Используйте библиотеку (go get github.com/ajstarks/svgo), создайте функцию DrawSVG(points []Point, filename string) для рисования полилинии в SVG-файл. Вызовите после фрактальной генерации.

### Часть 11: Симуляция эрозии (случайное смещение точек)
**Улучшение:** Введите динамику: модель эрозии как случайные сдвиги.  
**ТЗ:** Добавьте функцию Erode(points []Point, strength float64) []Point, которая для каждой точки добавляет случайный вектор (gauss распределение). Примените после фрактала, пересчитайте длину и размерность, сгенерируйте новый SVG.

### Часть 12: Множественные шаги симуляции эрозии
**Улучшение:** Сделайте симуляцию временной (несколько шагов).  
**ТЗ:** Создайте функцию SimulateErosion(points []Point, steps int, strength float64) [][]Point, возвращающую слайс состояний на каждом шаге. В main выведите метрики для каждого шага, сгенерируйте серию SVG-файлов.

### Часть 13: Concurrency для ускорения симуляций
**Улучшение:** Параллелизуйте вычисления для больших наборов точек.  
**ТЗ:** Используйте goroutines и sync.WaitGroup в SimulateErosion: разделите точки на chunks, эродируйте параллельно. Добавьте mutex для синхронизации. Тестируйте на большем наборе (100+ точек).

### Часть 14: Расчет площади прибрежных зон
**Улучшение:** Добавьте геометрические вычисления площади (shoelace formula).  
**ТЗ:** Предположите замкнутую область (добавьте базовую линию для "залива"). Создайте функцию Area(points []Point) float64 с shoelace. Вычисляйте площадь до/после эрозии, интегрируйте в симуляцию.

### Часть 15: Полноценное CLI-приложение с опциями
**Улучшение:** Сделайте программу полной: CLI с флагами, логирование, экспорт результатов.  
**ТЗ:** Используйте flag для параметров (iterations, steps, strength, output dir). В main: загрузите данные (HTTP или файл), примените фрактал, симулируйте эрозию с concurrency, вычислите метрики (длина, размерность, площадь), сгенерируйте SVG для каждого шага, экспортируйте JSON с результатами. Добавьте обработку ошибок и verbose logging. Это финальная robust реализация.